---
layout:     post
title:      最小生成树
subtitle:   poj1679
date:       2018-10-31
author:     roffett
header-img: img/landscape03.jpg
catalog: true
tags:
    - ACM
    - 最小生成树
    - POJ
---

### POJ 1679 次最小生成树

>  让你找到是否有2个相同的最小生成树

###### 输入第一行t  代表t组数据 第二行代表 n个点 m条边 之后就是边
###### 解题思路：
###### 1）先正常的算最小生成树
###### 2）然后标记最小生成树用过的边
###### 3）分别去掉用过的一条边再次计算最小生成树 算出值后先判断生成树是否联通，若不连通直接continue，若联通那么取最小值
###### 4）如果最小值和最小生成树的值一样，那么输出not unique，否则直接输出最小生成树的值

    #include<cstdio>
    #include<cstring>
    #include<vector>
    #include<algorithm>
    using namespace std;
    const int max_n = 105;
    int n,m,cnt=0,flag=0;
    int pre[max_n*max_n];
    struct edge{
        int from,to;
        int val;
        int use;
    }e[max_n*max_n];

    int locate[max_n];

    int cmp(edge a,edge b){
        return a.val<b.val;
    }

    void init(){
        cnt=0;
        memset(e,0,sizeof(e));
        for(int i = 0;i<=n;i++){
            pre[i]=i;
        }
    }

    int find(int x){
        if(x!=pre[x]){
            pre[x]= find(pre[x]);
        }
        return pre[x];
    }

    void join(int a,int b){
        int roota = find(a);
        int rootb = find(b);
        if(roota!=rootb){
            pre[roota] = rootb;
        }
        return ;
    }

    int kruskal(){
        int res = 0;
        sort(e,e+m,cmp);
        for(int i=0;i<m;i++){
            if(find(e[i].from)!=find(e[i].to)){
                res+=e[i].val;
                join(e[i].from,e[i].to);
                e[i].use = 1;
                locate[cnt++]=i;
            }
        }
        int res2;
        int mini=1e9;
        for(int i=0;i<cnt;i++){
            res2=0;flag = 0;
        for(int z=0;z<=n;z++){
            pre[z]=z;
        }
                for(int j=0;j<m;j++){
                if(j==locate[i]) continue;
                if(find(e[j].from)!=find(e[j].to)){
                res2+=e[j].val;
                join(e[j].from,e[j].to);
                }
        }
            for(int j=1;j<=n;j++){
                if(find(1)!=find(j)) {flag =1;break;}
            }
            if(flag == 1) continue;
            mini = min(mini,res2);
    }
        if(mini == res) res = -1;

        return res;
    }

    int main(){
        int t;
        scanf("%d",&t);
        while(t--){
            scanf("%d%d",&n,&m);
            init();
            for(int i=0;i<m;i++){
                scanf("%d%d%d",&e[i].from,&e[i].to,&e[i].val);
            }
            int res1=0;
            res1 = kruskal();
            if(res1!=-1)
            printf("%d\n",res1);
            else{
                printf("Not Unique!\n");
            }

        }

    }