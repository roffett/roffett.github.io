---
layout:     post
title:      最小生成树
subtitle:   HDU1863
date:       2018-10-30
author:     roffett
header-img: img/landscape02.jpg
catalog: true
tags:
    - ACM
    - 最小生成树
    - HDU
---

#### [hdu1863](http://acm.hdu.edu.cn/showproblem.php?pid=1863) 最小生成树的模板题
>!!!!!注意kruskal需要排序的，注意分清边和点的变量，注意数据格式longlong 

    #include<cstdio>	
    #include<cstring>
    #include<algorithm>
    using namespace std;
    const int max_n = 105;
    int pre[max_n * max_n];
    struct edge{
        int from,to;
        long long val;
    }e[max_n *max_n];

    int n,m;

    int find(int x){
        if(x!=pre[x]){
            pre[x] = find(pre[x]);
        }
        return pre[x];
    }

    int cmp(edge a,edge b){
        return a.val<b.val;
    }

    void join(int a,int b){
        int roota = find(a);
        int rootb = find(b);
        if(roota == rootb) return;
        pre[roota] = rootb;
    }

    void init(){
        for(int i=0;i<=m;i++){
            pre[i] = i;
        }
    }

    long long kruskal(){
        long long res = 0;
        sort(e+1,e+n+1,cmp);
        for(int i=1;i<=n;i++){
            if(find(e[i].from) == find(e[i].to)) continue;
            else{
                join(e[i].from,e[i].to);
                res += e[i].val;
            }
        }
        return res;
    }



    int main(){
        while(~scanf("%d%d",&n,&m)){
            init();
            if(n==0) break;
            for(int i=1;i<=n;i++){
                scanf("%d%d%lld",&e[i].from,&e[i].to,&e[i].val);
            }
            long long res = kruskal();
            for(int i=1;i<=m;i++){
                if(find(i) != find(1)) {res = -1;break;}
            }
            if(res==-1) printf("?\n");
            else printf("%lld\n",res);
        }

    }
